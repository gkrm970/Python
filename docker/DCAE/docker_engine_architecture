Docker Engine Architecture.
Docker Engine is a client-server application with these major components:
A server which is a type of long-running program called a daemon process (the dockerd command).
A REST API which specifies interfaces that programs can use to talk to the daemon and instruct it what to do.

Docker Architecture Diagram

A command line interface (CLI) client (the docker command).
A way to communicate with the daemon called the Docker client.
The CLI uses the Docker REST API to control or interact with the Docker daemon through scripting or direct CLI commands. Many other Docker applications use the underlying API and CLI.

The daemon creates and manages Docker objects, such as images, containers, networks, and volumes.

Docker objects.
    Images - The file system and configuration of our application which are used to create containers. To build your own image, you create a Dockerfile with a simple syntax for defining the steps needed to create the image and run it. Each instruction in a Dockerfile creates a layer in the image. When you change the Dockerfile and rebuild the image, only those layers which have changed are rebuilt. This is part of what makes images so lightweight, small, and fast, when compared to other virtualization technologies.
    Containers - Running instances of Docker images — containers run the actual applications. A container includes an application and all of its dependencies. It shares the kernel with other containers, and runs as an isolated process in user space on the host OS. Docker containers are not tied to any specific infrastructure: they run on any computer, on any infrastructure, and in any cloud.
    Networks - Networks provide communication between the Docker containers. Docker networks are used to enable communication between containers running on the same host or between different hosts. Several drivers exist by default, and provide core network functionality:
        bridge: The default network driver. If you don’t specify a driver, this is the type of network you are creating. Bridge networks are usually used when your applications run in standalone containers that need to communicate.
        host: For standalone containers, remove network isolation between the container and the Docker host, and use the host’s networking directly. host is only available for swarm services on Docker 17.06 and higher.
        overlay: Overlay networks connect multiple Docker daemons together and enable swarm services to communicate with each other. You can also use overlay networks to facilitate communication between a swarm service and a standalone container, or between two standalone containers on different Docker daemons. This strategy removes the need to do OS-level routing between these containers.
        macvlan: Macvlan networks allow you to assign a MAC address to a container, making it appear as a physical device on your network. The Docker daemon routes traffic to containers by their MAC addresses. Using the macvlan driver is sometimes the best choice when dealing with legacy applications that expect to be directly connected to the physical network, rather than routed through the Docker host’s network stack.
        none: For this container, disable all networking. Usually used in conjunction with a custom network driver. none is not available for swarm services.
    Volumes - Volumes are the preferred mechanism for persisting data generated by and used by Docker containers. While bind mounts are dependent on the directory structure of the host machine, volumes are completely managed by Docker. Volumes have several advantages over bind mounts:
        Volumes are easier to back up or migrate than bind mounts.
        You can manage volumes using Docker CLI commands or the Docker API.
        Volumes work on both Linux and Windows containers.
        Volumes can be more safely shared among multiple containers.
        Volume drivers let you store volumes on remote hosts or cloud providers, to encrypt the contents of volumes, or to add other functionality.
        New volumes can have their content pre-populated by a container.
        Volumes on Docker Desktop have much higher performance than bind mounts from Mac and Windows hosts.


Docker Registry.
    A Docker registry stores Docker images. Docker Hub and Docker Cloud are public registries that anyone can use, and Docker is configured to look for images on Docker Hub by default. You can even run your own private registry. If you use Docker Datacenter (DDC), it includes Docker Trusted Registry (DTR).

docker engine installation .
    https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/#install-docker-ce-1
    https://docs.docker.com/engine/installation/linux/linux-postinstall/#manage-docker-as-a-non-root-user

    sudo apt-get update
    sudo apt-get install \
        apt-transport-https \
        ca-certificates \
        curl \
        software-properties-common
    curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
    sudo apt-key fingerprint 0EBFCD88
    sudo add-apt-repository \
       "deb [arch=amd64] https://download.docker.com/linux/ubuntu \
       $(lsb_release -cs) \
       stable"
    sudo apt-get update
    sudo apt-get install docker-ce
    sudo docker run hello-world
    sudo groupadd docker
    sudo usermod -aG docker $USER
    docker run hello-world
    docker run -it ubuntu bash
    docker run -d -p 80:80 --name webserver nginx
    docker version
    docker info
    docker images
    docker --version
    docker system info
    docker system df
    docker container ls

    docker ps
    docker ps -a
    docker stop webserver
    docker rm webserver
    docker images
    docker rmi nginx
    docker run -d -p 80:80 --name webserver nginx
    docker exec -it webserver bash
    docker logs webserver
    docker inspect webserver
    docker inspect webserver | grep IPAddress
    docker inspect --format '{{ .NetworkSettings.IPAddress }}' webserver
    docker run -d -p 80:80 --name webserver nginx
    docker run -d -p 8080:80 --name webserver2 nginx
    docker run -d -p 8081:80 --name webserver3 nginx
    docker run -d -p 8082:80 --name webserver4 nginx
    docker run -d -p 8083:80 --name webserver5 nginx

Docker engine commands


