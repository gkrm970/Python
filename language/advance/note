list comprehension.
List comprehensions are a powerful tool in Python for creating new lists based on existing lists.
They provide a concise and expressive way to filter and transform elements from an iterable (like a list) and
generate a new list based on the filtered and transformed elements.

Basic Structure:

The basic structure of a list comprehension is as follows:
output_list = [output_expression for var in input_list if (var satisfies condition)]

output_list: The new list that will be created.

output_expression: The expression that generates the elements for the new list.
This expression can involve the current element (var), other variables, and any valid Python expression.

for var in input_list: This part iterates over each element (var) in the input_list.

if (var satisfies condition): This optional conditional expression filters the elements.
If the condition evaluates to True for an element, then that element is included in the new list.

Applications:

List comprehensions have a wide range of applications in Python programming. Here are some common examples:

Filtering: Extract specific elements from a list based on a condition.
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]
evens = [num for num in numbers if num % 2 == 0]
print(evens)  # Output: [2, 4, 6, 8]

Combining: Combine elements from multiple lists into a new list.
names = ['Alice', 'Bob', 'Charlie']
ages = [30, 25, 22]
name_age_pairs = [(name, age) for name, age in zip(names, ages)]
print(name_age_pairs)  # Output: [('Alice', 30), ('Bob', 25), ('Charlie', 22)]

List comprehensions offer a concise and readable way to perform filtering, transformation, and combination operations on lists.
They are an essential part of Python's expressive power and are widely used in various programming tasks.

dictionary comprehension.
Dictionary comprehensions are a powerful feature that allows us to create new dictionaries in a very concise way.
They are similar to list comprehensions, but they produce dictionaries instead of lists.

Basic Structure:

The basic structure of a dictionary comprehension is as follows:
output_dict = {key:value for (key, value) in iterable if (key, value satisfy this condition)}

output_dict: The new dictionary that will be created.

key: The key of the new dictionary.
value: The value associated with the key.

iterable: An iterable object like a list, tuple, set, etc.

if (key, value satisfy this condition): This optional conditional expression filters the elements.
If the condition evaluates to True, then the (key, value) pair is included in the new dictionary.

Applications:

Dictionary comprehensions have a wide range of applications in Python programming. Here are some common examples:

Filtering: Extract specific key-value pairs from a dictionary based on a condition.
numbers = {'first': 1, 'second': 2, 'third': 3, 'fourth': 4}
even_numbers = {key:value for (key, value) in numbers.items() if value % 2 == 0}
print(even_numbers)  # Output: {'second': 2, 'fourth': 4}

Combining: Combine elements from multiple dictionaries into a new dictionary.
names = {'Alice': 30, 'Bob': 25, 'Charlie': 22}
ages = {'Alice': 27, 'Bob': 24, 'Charlie': 21}
name_age = {key: value for key, value in zip(names, ages)}
print(name_age)  # Output: {'Alice': 27, 'Bob': 24, 'Charlie': 21}

Dictionary comprehensions offer a concise and readable way to perform filtering, transformation, and combination operations on dictionaries.
They are an essential part of Python's expressive power and are widely used in various programming tasks.

set comprehension.
Set comprehensions are a powerful feature that allows us to create new sets in a very concise way.
They are similar to list comprehensions, but they produce sets instead of lists.

Basic Structure:

The basic structure of a set comprehension is as follows:
output_set = {expression for var in input_set if (var satisfies this condition)}

output_set: The new set that will be created.

expression: The expression that generates the elements for the new set.
This expression can involve the current element (var), other variables, and any valid Python expression.

for var in input_set: This part iterates over each element (var) in the input_set.

if (var satisfies condition): This optional conditional expression filters the elements.
If the condition evaluates to True for an element, then that element is included in the new set.

Applications:

Set comprehensions have a wide range of applications in Python programming. Here are some common examples:

Filtering: Extract specific elements from a set based on a condition.
numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9}
evens = {num for num in numbers if num % 2 == 0}
print(evens)  # Output: {8, 2, 4, 6}

Combining: Combine elements from multiple sets into a new set.
names = {'Alice', 'Bob', 'Charlie'}
ages = {30, 25, 22}

name_age_pairs = {(name, age) for name, age in zip(names, ages)}
print(name_age_pairs)  # Output: {('Bob', 25), ('Charlie', 22), ('Alice', 30)}

Set comprehensions offer a concise and readable way to perform filtering, transformation, and combination operations on sets.
They are an essential part of Python's expressive power and are widely used in various programming tasks.

generator comprehension.
Generator comprehensions are a powerful feature that allows us to create new generators in a very concise way.
They are similar to list comprehensions, but they produce generators instead of lists.

Basic Structure:

The basic structure of a generator comprehension is as follows:
output_generator = (expression for var in input_generator if (var satisfies this condition))

output_generator: The new generator that will be created.

expression: The expression that generates the elements for the new generator.
This expression can involve the current element (var), other variables, and any valid Python expression.

for var in input_generator: This part iterates over each element (var) in the input_generator.

if (var satisfies condition): This optional conditional expression filters the elements.
If the condition evaluates to True for an element, then that element is included in the new generator.

Applications:

Generator comprehensions have a wide range of applications in Python programming. Here are some common examples:

Filtering: Extract specific elements from a generator based on a condition.
numbers = (1, 2, 3, 4, 5, 6, 7, 8, 9)
evens = (num for num in numbers if num % 2 == 0)
print(evens)  # Output: <generator object <genexpr> at 0x7f9b8c1b3f20>

Combining: Combine elements from multiple generators into a new generator.
names = ('Alice', 'Bob', 'Charlie')
ages = (30, 25, 22)

name_age_pairs = ((name, age) for name, age in zip(names, ages))
print(name_age_pairs)  # Output: <generator object <genexpr> at 0x7f9b8c1b3f20>

Generator comprehensions offer a concise and readable way to perform filtering, transformation, and combination operations on generators.
They are an essential part of Python's expressive power and are widely used in various programming tasks.

*******************************************************************************

lambda function
==============
Table of contents
------------------
What is Lambda Function in Python?
Using Lambda with Python Built-ins?
Why and When to Use Lambda Functions?
Lambda vs. Regular Functions?
Key Takeaways?


The Python lambda functions are similar to user-defined functions but are anonymous with No name.
It is typically a small and restricted function that can’t have more than one line. 

every anonymous function defined in the Python programming language will have three essential parts- 
the lambda keyword, the parameters, and the function body.

Python Lambda Function Syntax
==================================
Lambda argument (s): expression

Using Lambda with Python Built-ins.
----------------------------
lambdas are callable as soon as they are defined and passed as an argument to Python’s built-in functions

Example1:
lambda functions can be used to return function objects. Lambda functions are anonymous functions that are defined
without a name. They are often used to create simple functions on the fly.

Here are a few examples of how lambda functions can be used to return function objects:

Return a function that adds a specific number to an argument:
add_five = lambda x: x + 5
result = add_five(10)
print(result)  # Output: 15

Return a function that multiplies two arguments:
multiply = lambda x, y: x * y
result = multiply(10, 5)
print(result)  # Output: 50

Return a function that can be used to sort a list:
sort_by_last_letter = lambda x: x[-1]
names = ['Alice', 'Bob', 'Charlie', 'Diana', 'Eve']
names.sort(key=sort_by_last_letter)


Example2:
Return a function that checks if a number is even:
is_even = lambda x: x % 2 == 0
is_ten_even = is_even(10)
print(is_ten_even)  # Output: True


Lambda Function with other function
----------------------------------
Filter()-->
A filter function in Python will require another function containing the expression or operation that is to be performed on the iterator.

filter(function, sequence)

Parameters:
function: function that tests if each element of a sequence true or not.
sequence: sequence which needs to be filtered, it can be sets, lists, tuples, or containers of any iterators.

example1:
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]
even_numbers = list(filter(lambda x: x % 2 == 0, numbers))
print(even_numbers)  # Output: [2, 4, 6, 8]

example2:
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]
odd_numbers = list(filter(lambda x: x % 2 != 0, numbers))
print(odd_numbers)  # Output: [1, 3, 5, 7, 9]


Lambda Function with Map()
----------------------------
The map() function is used for applying a particular operation to each value in a sequence so that they can be modified. 
map() function returns a map object(which is an iterator) of the results after applying
the given function to each item of a given iterable (list, tuple etc.) Syntax :

map(fun, iter)

Example1:
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]
squares = list(map(lambda x: x**2, numbers))
print(squares)  # Output: [1, 4, 9, 16, 25, 36, 49, 64, 81]

Example2:
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]
cubes = list(map(lambda x: x**3, numbers))
print(cubes)  # Output: [1, 8, 27, 64, 125, 216, 343, 512, 729]


Lambda Function with Reduce()
-----------------------------
Similarly to the map() function, the reduce() function is also used for applying a particular operation to each value in
a sequence so that they can be modified. However, the working of reduce function is quite different from the map function
. This particular built-in function of Python performs a repetitive operation over the pairs given in the sequence.

function is used to apply a particular function passed in its argument to all of the list elements mentioned in
the sequence passed along.This function is defined in “functools” module.

The reduce(fun,seq)
function is used to apply a particular function passed in its argument to all of the list elements mentioned in
the sequence passed along.This function is defined in “functools” module.

Example1:
from functools import reduce
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]
sum = reduce(lambda x, y: x + y, numbers)
print(sum)  # Output: 45

Example2:
from functools import reduce
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]
product = reduce(lambda x, y: x * y, numbers)
print(product)  # Output: 362880

zip() function
---------------------------
The zip() function in Python programming is a built-in standard function that takes multiple iterables or containers
as parameters. This function then returns a list of tuples containing elements from each iterable.


In Python, the zip() function is a built-in function that takes one or more iterables (such as lists, tuples, or strings)
and aggregates the elements from each iterable into a single iterator of tuples.
Each tuple contains the corresponding elements from each input iterable.

Syntax:

The zip() function has the following syntax:
zip(*iterables)

The * operator before the iterables argument allows you to unpack a sequence of iterables.
This means you can pass multiple iterables directly to the zip() function.

Applications:

The zip() function has various applications in Python programming, including:

Pairing Elements: Combine elements from multiple iterables into pairs.
names = ['Alice', 'Bob', 'Charlie']
ages = [30, 25, 22]
name_age_pairs = list(zip(names, ages))
print(name_age_pairs)  # Output: [('Alice', 30), ('Bob', 25), ('Charlie', 22)]

Iterating Synchronously: Iterate over multiple iterables in parallel, stopping when the shortest iterable is exhausted.
numbers = [1, 2, 3, 4]
letters = ['a', 'b', 'c']

for num, letter in zip(numbers, letters):
    print(f"{num} - {letter}")
# Output:

Unpacking Arguments: Unpack arguments for functions that take multiple arguments from a single iterable.
def print_product(x, y):
    print(x * y)

factors = [(2, 5), (3, 4), (6, 7)]

for factor in factors:
    print_product(*factor)  # Unpack 'factor' tuple into individual arguments

The zip() function is a versatile tool for combining, iterating, and unpacking data from multiple iterables,
making it a valuable addition to the Python programmer's toolkit.


*** why lambda function is used with map(), filter(), reduce()?
------------------------------------------------------------
Lambdas enable a developer to provide a function as a parameter to another Python built-in function
(for instance, in the map, filter, reduce, etc.).

Why and When to Use Lambda Functions?
--------------------------------------
Lambda functions are used when you need a small function that does not need to be named or defined.
Lambda functions are mainly used in combination with the functions filter(), map() and reduce().
The lambda feature was added to Python due to the demand from Lisp programmers.

Lambda vs. Regular Functions?
------------------------------
The lambda keyword is used to create anonymous functions. It has the following syntax:
lambda arguments: expression

Regular functions are created using the def keyword. It has the following syntax:
def function_name(arguments):
    expression

Key Takeaways
--------------
Lambda functions are anonymous functions in Python.
Lambda functions can have any number of arguments but only one expression.
Lambda functions can be used to return function objects.
Lambda functions are mainly used in combination with the functions filter(), map() and reduce().

*******************************************************************************

