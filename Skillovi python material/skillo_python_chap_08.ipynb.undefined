{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Lambda expressions\n",
    "\n",
    "Lambda expressions (sometimes called lambda forms) are used to create anonymous functions.\n",
    "<br> They are called anonymous functions because they don't have any name.\n",
    "<br> Lambda expressions can be used as an alternative for one line functions.\n",
    "<br> They can have one or more than one arguments but can have have only one expression.\n",
    "<br> It is a very handy tool when you will deal with pandas dataframes. *Don't worry about pandas, this will be covered when you start your data science journey*\n",
    "\n",
    "The syntax is :\n",
    "<br>\n",
    "```python\n",
    "lambda arguments: expression   \n",
    "```\n",
    "\n",
    "For further reference: https://docs.python.org/3/reference/expressions.html#lambda"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Addition of two numbers using lambda function."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "whenever you want to call a function inside a function... use lambda./"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def add(x, y):\n",
    "    return x+y"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "add = lambda x,y : x+y"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": 112,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "add = lambda x, y : x + y"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 113,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "5"
      ]
     },
     "execution_count": 113,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "add(2,3)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Find square of a number using lambda function."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 114,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "square = lambda x : x**2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 115,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "25"
      ]
     },
     "execution_count": 115,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "square(5)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "This is equivalent to :"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 116,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "def square(x):\n",
    "    \n",
    "    return x ** 2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 117,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "25"
      ]
     },
     "execution_count": 117,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "square(5)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Lambda function to print Cheers"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 173,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Cheers\n"
     ]
    }
   ],
   "source": [
    "cheers = lambda  : \"Cheers\"\n",
    "\n",
    "print(cheers())"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "So, when to use lambda expressions over functions?\n",
    "\n",
    "When you have more than one line of code to be executed. Put those lines in a function otherwise use lambda expressions."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": true
   },
   "source": [
    "## Predefined functions or Builtin Functions\n",
    "\n",
    "Uptil now, we have been using built in functions knowingly or unknowingly. So lets go through a few of them formally.\n",
    "\n",
    "Remember you had studied strings, lists, etc. There we have used various methods/functions, these were the predefined functions that are most commonly needed to work on an object type.\n",
    "<br> There are 2 to 3 ways to find the right method which you need at the particular situation.\n",
    "   1. After creating the object press '.' and then press Tab, which will give you a list of all the available methods.\n",
    "   2. You can refer to Python documentation of that particular class (eg. String, list, etc).\n",
    "   3. You can Google Search for your problem (eg. Count the number of character in the string) and you would likely see Google results pointing to the Stackoverflow page."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Advanced functions - zip, map, reduce and filter\n",
    "\n",
    "<br> Lets look at some more advanced functions which we have not covered before.\n",
    "<br> Lets go over these functions one by one."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Map function\n",
    "\n",
    "map() is a function that takes in two arguments: a function and a sequence iterable. In the form: map(function, sequence)\n",
    "\n",
    "The first argument is the name of a function and the second a sequence (e.g. a list). map() applies the function to all the elements of the sequence. It returns a new list with the elements changed by function.\n",
    "\n",
    "It is very similar to list comprehension.\n",
    "\n",
    "For further reference: https://docs.python.org/3/library/functions.html#map"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "metadata": {},
   "outputs": [],
   "source": [
    "mi_players = [\"Rohit Sharma\", \"Jasprit Bumrah\", \"Siddhesh Lad\", \"Ishan Kishan\", \"Hardik Pandya\"]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<br> Lambda functions independently are not used many a times but they are quite often used along with map, reduce and filter."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Lets use map function to get the first names of *mi_players* "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "['Rohit', 'Jasprit', 'Siddhesh', 'Ishan', 'Hardik']"
      ]
     },
     "execution_count": 32,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "list(map(lambda x : x.split()[0], mi_players))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Working:\n",
    "    - map() function maps the split() function on every element of mi_players and the result is map object.\n",
    "    - In order to retrieve a list from map object we need to convert it to list."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Lets use map function to get the last names of *mi_players* "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 120,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "['Sharma', 'Bumrah', 'Lad', 'Kishan', 'Pandya']"
      ]
     },
     "execution_count": 120,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "list(map(lambda x : x.split()[1],mi_players))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Given the runs scored by players in 3 matches.\n",
    "<br> Find the sum of runs scored by each player."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Reduce function\n",
    "\n",
    "This is a bit tough part to understand. The function reduce(function, sequence) continually applies the function to the sequence. It then returns a single value.\n",
    "\n",
    "If seq = [ s1, s2, s3, ... , sn ], calling reduce(function, sequence) works like this:\n",
    "\n",
    "At first the first two elements of seq will be applied to function, i.e. func(s1,s2)\n",
    "<br>The list on which reduce() works looks now like this: [ function(s1, s2), s3, ... , sn ]\n",
    "<br>In the next step the function will be applied on the previous result and the third element of the list, i.e. function(function(s1, s2),s3)\n",
    "<br>The list looks like this now: [ function(function(s1, s2),s3), ... , sn ]\n",
    "<br>It continues like this until just one element is left and return this element as the result of reduce()\n",
    "\n",
    "For further reference:\n",
    "https://docs.python.org/3/library/functools.html#functools.reduce\n",
    "\n",
    "In the following figure, you can see that \n",
    "> 1 and 2 are added to give 3.\n",
    "> <br>  3 is added with 3 to give 6.\n",
    "> <br>  6 is added with 4 to give 10.\n",
    "\n",
    "A cumulative process takes place in reduce."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Using reduce() find the maximum of the below list"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 122,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "l = [4,2,3,1]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 123,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "# import reduce\n",
    "\n",
    "from functools import reduce"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 124,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "4"
      ]
     },
     "execution_count": 124,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#Find the maximum of a sequence (This already exists as max())\n",
    "find_max = lambda a,b: a if (a > b) else b\n",
    "\n",
    "#Find max\n",
    "reduce(find_max,l)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Using the details dictionary created above find the details of employee with maximum salary"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 125,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "('Tom', {'designation': 'Managing Director', 'salary': 100000})"
      ]
     },
     "execution_count": 125,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "reduce(lambda a,b: a if (a[1]['salary'] > b[1]['salary']) else b,list(details.items()))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Filter function"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The function filter(function, sequence) offers a convenient way to filter out all the elements of an iterable, for which the function returns True.\n",
    "\n",
    "The function filter(function,sequence) needs a function as its first argument. The function needs to return a boolean value (either True or False). This function will be applied to every element of the iterable. Only if the function returns True will the element of the iterable be included in the result.\n",
    "\n",
    "For further reference: https://docs.python.org/3.6/library/functions.html#filter\n",
    "\n",
    "Lets see some examples:"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Given the list l, print all the even numbers in the list."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 132,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "l = [3,2,1,5,7,12,14,13]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 134,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[2, 12, 14]"
      ]
     },
     "execution_count": 134,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "list(filter(lambda x: x%2==0,l))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Below printed is the dictionary we had created before, display the details of employees with salary greater than 45000."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 126,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'Arun': {'designation': 'Manager', 'salary': 50000},\n",
       " 'Manish': {'designation': 'Senior Manager', 'salary': 70000},\n",
       " 'Tom': {'designation': 'Managing Director', 'salary': 100000},\n",
       " 'Zahir': {'designation': 'Associate', 'salary': 40000}}"
      ]
     },
     "execution_count": 126,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "details"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 131,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[('Arun', {'designation': 'Manager', 'salary': 50000}),\n",
       " ('Manish', {'designation': 'Senior Manager', 'salary': 70000}),\n",
       " ('Tom', {'designation': 'Managing Director', 'salary': 100000})]"
      ]
     },
     "execution_count": 131,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "list(filter(lambda a: a[1]['salary'] > 45000,list(details.items())))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Zip function\n",
    "\n",
    "We have used zip function before in compound data types.\n",
    "<br>zip() makes an iterator that aggregates elements from each of the iterables.\n",
    "\n",
    "Returns an iterator of tuples, where the i-th tuple contains the i-th element from each of the argument sequences or iterables. The iterator stops when the shortest input iterable is exhausted. With a single iterable argument, it returns an iterator of 1-tuples. With no arguments, it returns an empty iterator.\n",
    "\n",
    "zip() is equivalent to:\n",
    "\n",
    "```python\n",
    "def zip(*iterables):\n",
    "    # zip('ABCD', 'xy') --> Ax By\n",
    "    sentinel = object()\n",
    "    iterators = [iter(it) for it in iterables]\n",
    "    while iterators:\n",
    "        result = []\n",
    "        for it in iterators:\n",
    "            elem = next(it, sentinel)\n",
    "            if elem is sentinel:\n",
    "                return\n",
    "            result.append(elem)\n",
    "        yield tuple(result)\n",
    "```\n",
    "\n",
    "zip() should only be used with unequal length inputs when you donâ€™t care about trailing, unmatched values from the longer iterables.\n",
    "\n",
    "For further reference: https://docs.python.org/3.6/library/functions.html#zip\n",
    "\n",
    "Lets see it in action in some examples:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 103,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[('A', 'x'), ('B', 'y')]"
      ]
     },
     "execution_count": 103,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "list(zip('ABCD', 'xy'))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'a': 0, 'b': 9}"
      ]
     },
     "execution_count": 33,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "l = ['a', 'b']\n",
    "m = [0, 9]\n",
    "dict(zip(l, m))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "In the above example, length of 'ABCD' is not same 'xy', that is why only first two characters of the 2 strings were zipped together."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Using zip function create a list names with first name and last name of each player"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 108,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "['Rohit Sharma', 'Jasprit Bumrah', 'Siddhesh Lad', 'Ishan Kishan', 'Hardik Pandya']\n"
     ]
    }
   ],
   "source": [
    "first_names = ['Rohit', 'Jasprit', 'Siddhesh', 'Ishan', 'Hardik']\n",
    "last_names = ['Sharma', 'Bumrah', 'Lad', 'Kishan', 'Pandya']\n",
    "\n",
    "# Concatenate names with space between them\n",
    "names = [i+' '+j for i,j in zip(first_names,last_names)]\n",
    "\n",
    "print(names)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
